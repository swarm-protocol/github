# =============================================================================
# Dockerfile Template for GitHub Copilot Custom Agent Projects
# =============================================================================
# This is a template Dockerfile demonstrating best practices for containerizing
# Node.js applications. Copy this file to your project and customize the TODO
# sections marked below.
#
# Key Features:
# - Multi-stage build for smaller production images
# - Alpine Linux base for minimal image size
# - Non-root user for enhanced security
# - Layer optimization for faster builds
# - Health checks for container orchestration
# - Comprehensive metadata labels
#
# Usage:
#   1. Copy this file and rename to `DOCKERFILE`
#   2. Replace all TODO sections with your application specifics
#   3. Ensure you have a `.dockerignore` file (see .dockerignore in this repo)
#   4. Build: docker build -t your-app:tag .
#   5. Run: docker run -d -p 3000:3000 your-app:tag
# =============================================================================

# -----------------------------------------------------------------------------
# Build Stage: Compile and prepare application
# -----------------------------------------------------------------------------
# This stage installs all dependencies and builds the application.
# It will not be included in the final image, keeping production lean.

FROM node:18.17.1-alpine3.18 AS builder

# Set metadata labels for the image
LABEL maintainer="your-email@example.com"
LABEL description="TODO: Add your application description"
LABEL version="1.0.0"

# Set working directory
WORKDIR /app

# Copy package files first for better layer caching
# Docker will only rebuild from here if package files change
COPY package*.json ./

# TODO: If using Yarn, use this instead:
# COPY package.json yarn.lock ./
# RUN yarn install --frozen-lockfile --production=false

# Install ALL dependencies (including devDependencies for build)
RUN npm ci --include=dev

# Copy application source code
COPY . .

# TODO: Customize the build command for your application
# Examples:
#   - TypeScript: RUN npm run build
#   - React/Vue: RUN npm run build
#   - No build step: Remove this line
RUN npm run build

# TODO: If you don't need a build step, you can remove this stage entirely
# and use a single-stage Dockerfile

# -----------------------------------------------------------------------------
# Production Stage: Minimal runtime image
# -----------------------------------------------------------------------------
# This stage contains only production dependencies and built artifacts,
# resulting in a much smaller and more secure final image.

FROM node:18.17.1-alpine3.18

# Install security updates and any runtime dependencies
# TODO: Add any runtime system dependencies your app needs
# Example: RUN apk add --no-cache curl postgresql-client
RUN apk update && \
    apk upgrade && \
    rm -rf /var/cache/apk/*

# Create a non-root user for running the application
# Running as non-root is a security best practice
RUN addgroup -g 1000 appgroup && \
    adduser -D -u 1000 -G appgroup appuser

# Set working directory
WORKDIR /app

# Copy package files for production install
COPY package*.json ./

# Install ONLY production dependencies
RUN npm ci --omit=dev && \
    npm cache clean --force

# Copy built artifacts from builder stage
# TODO: Adjust paths based on your build output directory
# Common examples:
#   - TypeScript: COPY --from=builder /app/dist ./dist
#   - React (served by Node): COPY --from=builder /app/build ./build
#   - Next.js: COPY --from=builder /app/.next ./.next
#   - No build: COPY --from=builder /app/src ./src
COPY --from=builder --chown=appuser:appgroup /app/dist ./dist

# TODO: Copy any additional runtime files needed
# Examples:
#   COPY --chown=appuser:appgroup ./config ./config
#   COPY --chown=appuser:appgroup ./public ./public
COPY --chown=appuser:appgroup ./public ./public

# Change ownership of all application files to non-root user
RUN chown -R appuser:appgroup /app

# Switch to non-root user
USER appuser

# TODO: Set the port your application listens on
# Update both the EXPOSE and health check if using a different port
EXPOSE 3000

# Environment variables
# TODO: Set appropriate environment variables for production
ENV NODE_ENV=production \
    PORT=3000

# Health check configuration
# This allows Docker/Kubernetes to monitor application health
# TODO: Update the health check endpoint and port for your application
HEALTHCHECK --interval=30s --timeout=5s --start-period=10s --retries=3 \
    CMD node -e "require('http').get('http://localhost:3000/health', (r) => {process.exit(r.statusCode === 200 ? 0 : 1)})" || exit 1

# TODO: Alternative health checks:
# Using wget (requires installation): CMD wget --quiet --tries=1 --spider http://localhost:3000/health || exit 1
# Using curl (requires installation): CMD curl -f http://localhost:3000/health || exit 1

# TODO: Update the start command for your application
# Common examples:
#   - Production server: CMD ["node", "dist/index.js"]
#   - Express app: CMD ["node", "dist/server.js"]
#   - Next.js: CMD ["npm", "start"]
#   - Custom script: CMD ["node", "dist/main.js"]
CMD ["node", "dist/index.js"]

# -----------------------------------------------------------------------------
# Development Stage (Optional)
# -----------------------------------------------------------------------------
# Uncomment this section if you want a development container with hot reload
# Build with: docker build --target development -t your-app:dev .

# FROM node:18.17.1-alpine3.18 AS development
# WORKDIR /app
# COPY package*.json ./
# RUN npm ci
# COPY . .
# EXPOSE 3000
# ENV NODE_ENV=development
# CMD ["npm", "run", "dev"]

# =============================================================================
# Build and Run Examples
# =============================================================================
#
# Build production image:
#   docker build -t my-app:1.0.0 .
#
# Build with no cache:
#   docker build --no-cache -t my-app:1.0.0 .
#
# Build development image (if development stage is uncommented):
#   docker build --target development -t my-app:dev .
#
# Run container:
#   docker run -d -p 3000:3000 --name my-app my-app:1.0.0
#
# Run with environment variables:
#   docker run -d -p 3000:3000 -e DATABASE_URL=postgres://... my-app:1.0.0
#
# Run with volume mount for logs:
#   docker run -d -p 3000:3000 -v ./logs:/app/logs my-app:1.0.0
#
# Check container logs:
#   docker logs -f my-app
#
# Check health status:
#   docker inspect --format='{{.State.Health.Status}}' my-app
#
# =============================================================================
